ATIF HAMMUD ALI
Aali309@myseneca.ca
116743196
NBB Final Project part 2 "reflect.txt"

	First before I discuss deeper on modular programming, one should understand what modular programming means. Modular programming is the process of subdividing a computer program into little readable and reusable programs. This assignment benefitted from modular programming by making modules for code parts that are redundant. The functionality of this program was done by coding multiple functions, six to be exact. “getAgeGroup” which is responsible for identifying and, setting the appropriate age group name according to the age of the bike rider. We had to make it a function because in the program this task is repeated several times. The “getTime” function takes the times of the rider which is in a different format and converts it into another format which matches the sample output (i.e. formatted time string). This task is also done multiple times. The “getCategory” function takes the category as a pointer together with the race and finds the right category according to the race (as per the sample output given to us) and returns it. This also is a repeated task in the program that is going to be done by just calling the function instead of typing the code again and again every time this task is needed be done. To know whether a racer has withdrawn a race or not, “getWithdraw” function comes in place. This function converts the integer value to a “Yes” if any rider has withdrawn, or a “No” if none has withdrawn. To take data of one “RiderInfo” to the other, we used the “copyInfo” function. The sort function (“sortElements”), also comes in handy. This function uses a different logic. It sorts the riders according to their “finishTime” . A different function just to perform this task also takes so much benefit from modular programming. However, to make sure that these modules are efficient, we had to make sure they are highly cohesive (i.e. performs one single task) and less coupling (relatedness of one module to another). I personally learnt while doing this assignment that modular programming has so many advantages. For instance, development of the program could be divided which allowed us to work simultaneously and minimizes time used especially these times of exams. Errors were easy to detect and fix because the program was easy to read. To manage it is easy as well and the functions could be used several times whenever needed instead of typing the whole code again and again. I believe that our group also benefitted from this program’s aspect of modular programming because, all three of us could focus on our individual parts of the same code.
	I learnt that “int” has 2 to 4 bytes and that “char” has 1byte. So, in our case, instead of using the full name of a specific category, we used “char” instead of using array of characters (c string) to save the category name for the race. We used ‘S’, ‘M’, ‘L’ to save the 50 km ,75 km and 100 km races respectively. This style saves memory. We would have definitely used more memory to save the race category name as a “c string” compared to just a “char”. One other method is to use “int” in our function instead of “char” that classifies the category of the race. As I mentioned at the beginning of the paragraph that “int” has 2 to 4bytes and “char” has 1byte, our way of using “char” instead of “int” is more efficient in saving memory because less memory is used.
	The “feof()” function is a file handling function in c programming that is used to determine the end of a file. Also, the rider’s data is stored in different variable, which explains the difficulty in reading the data in the file. The “readFileRcord” in our program uses the “feof()” method. It is reading the data of rider in parts and one by one checks for missing parts i.e. checking if withdrawn (whether a rider who has withdrawn is present or not). Also it uses a function that clears the input buffer until the end of line of the file is reached. Therefore the end of line is determined by “ch !=’\n’ ” and end of file is determined by “(!feof(fp))” .If end of file is reached the function will return 1. Another way of determining the missing parts by reading line by line and execute it. This will start reading from the very top, read the first line, make the parts of the line and pass it into the appropriate data types and set the default values for those properties that are missing.
	
